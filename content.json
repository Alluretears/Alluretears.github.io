[{"title":"使用ACTION_IMAGE_CAPTURE可能存在的风险","date":"2017-09-04T03:16:11.000Z","path":"2017/09/04/action-image-capture-issue/","text":"很多的 Android App 中都有使用相机拍摄用户头像的功能。大部分开发者都会使用MediaStore.ACTION_IMAGE_CAPTURE来满足这一需求。这可以节省很多时间，不需要单独开发相机UI，直接调用系统相机；不需要向系统请求 Camera 权限。正如官方文档里面说的那样，Taking Photos Simply。然而在最近的一次的测试中，我发现并没有那么简单。因为运行了几年的代码竟然发生了 Crash。具体的 log 如下： java.lang.SecurityException: Permission Denial: starting Intent { act=android.media.action.IMAGE_CAPTURE cat=[android.intent.category.DEFAULT] flg=0x3 cmp=com.google.android.GoogleCamera/com.android.camera.activity.CaptureActivity clip={text/uri-list U:content://com.imzhiqiang.example.fileprovider/imageCache/tmp_avatar.jpg} (has extras) } from ProcessRecord{bf70afd 18107:com.imzhiqiang.example/u0a108} (pid=18107, uid=10108) with revoked permission android.permission.CAMERA 看上去是因为没有处理运行时权限导致的 Crash。Interesting! 我并没有在 manifest 文件中声明 Camera 的权限，为什么会出现没有处理 Camera 运行时权限的问题呢？随后我想到了可能是引用的 library 中声明了该权限。在 Android Studio 中查看了 Merged Manifest，果然是这样。图中深色背景的权限是我自己声明的，下面的权限是第三方的 library 声明的。 然而这和 Intent 又有什么关系？使用 ACTION_IMAGE_CAPTURE 不是可以避免请求 Camera 权限吗？经过几番周折过后，最后终于在官方文档中找到了答案。 虽然很难理解 Google 这样的做法，不过总算找到了问题的根本所在。在对 Camera 权限进行正确的处理后，终于正常运行了。 结论 如果没有在 manifest 文件中声明 Camera 权限，使用 ACTION_IMAGE_CAPTURE 不需要对 Camera 权限做运行时权限处理，代码正常运行。如果声明了就必须要做权限处理。 使用 Intent 的 action 时，一定要仔细阅读官方文档，避免类似的风险。 引用第三方 library 时，除了熟悉其内部原理和源码外，还要注意它在 manifest 文件中添加的东西。 扩展阅读 Taking Photos Not So Simply: How I Got Bitten By ACTION_IMAGE_CAPTURE Use intent ACTION_IMAGE_CAPTURE to launch camera app requires CAMERA permission The ACTION_IMAGE_CAPTURE Fallacy","tags":[]},{"title":"Glide中的缓存","date":"2017-03-05T07:49:32.000Z","path":"2017/03/05/Cache-in-Glide/","text":"本文主要介绍了如何配置和管理Glide中的缓存，其中大部分内容都可以直接在官方Wiki中找到，这里只是进行了整理和汇总。言归正传，Glide支持图片的二级缓存(并不是三级缓存，因为从网络加载并不属于缓存)，即内存缓存和磁盘缓存。 磁盘缓存一般的图片缓存指的就是磁盘缓存，把网络上的图片缓存到本地，这样就不需要每次都从网络加载，既提高了加载速度，又为用户节省了流量。Glide在默认情况下是开启磁盘缓存的，而且提供了丰富的API来让开发者自己配置和管理磁盘缓存。 缓存位置和大小开发者可以通过构建一个自定义的GlideModule来配置Glide磁盘缓存的位置和大小。最简单的方法如下：1234567891011121314public class DiskCacheMoudle implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; builder.setDiskCache( new InternalCacheDiskCacheFactory(context, \"glide_cache\", 100 * 1024 * 1024)); //builder.setDiskCache( // new ExternalCacheDiskCacheFactory(context, \"glide_cache\", 100 * 1024 * 1024)); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; &#125;&#125; 其中InternalCache和ExternalCache都最多接收3个参数：第一个参数为Context,没啥好说的；第二个为缓存的目录名称；第三个为缓存大小，单位是Byte。它们之间唯一的不同就在于InternalCache构建的缓存是在应用的内部储存，而ExternalCache则是在外部储存。内部储存中的缓存文件是其他应用程序是无法获取到的，更加安全。关于内部储存和外部储存的更多内容，请点击这里查看官方文档。 如果不想把缓存放在上面的两个位置怎么办？Glide当然也支持，具体通过DiskLruCacheFactory来实现：1234567builder.setDiskCache( new DiskLruCacheFactory(new DiskLruCacheFactory.CacheDirectoryGetter() &#123; @Override public File getCacheDirectory() &#123; return getMyCacheLocationBlockingIO(); &#125; &#125;), 100 * 1024 * 1024); Note: getMyCacheLocationBlockingIO方法返回的文件不能为空，而且必须是一个已经创建好的文件目录，不可以是文件。 缓存策略与其他图片加载库的缓存机制不同，Glide缓存图片时默认只缓存最终加载的那张图片。举个栗子，你要加载的图片分辨率为1000x1000，但是最终显示该图片的ImageView大小只有500x500，那么Glide就会只缓存500x500的小图。这也是在从磁盘缓存中加载图片时Glide比Picasso快的原因。Glide目前提供了四种缓存策略： DiskCacheStrategy.NONE 不缓存文件 DiskCacheStrategy.SOURCE 只缓存原图 DiskCacheStrategy.RESULT 只缓存最终加载的图（默认的缓存策略） DiskCacheStrategy.ALL 同时缓存原图和结果图 缓存算法在Glide中磁盘缓存默认使用的是LRU（Least Recently Used）算法。如果你想使用其他的缓存算法，就只能通过实现DiskCache接口来完成了。 内存缓存使用内存缓存可以获得更快的图片加载速度，因为减少了耗时的IO操作。众所周知，Bitmap是Android中的内存大户，频繁的创建和回收Bitmap必然会引起内存抖动。Glide中有一个叫做BitmapPool的类，可以复用其中的Bitmap对象，从而避免Bitmap对象的创建，减小内存开销。当配置内存缓存时，我们也应该同时配置BitmapPool的大小。具体方法也是通过自定义的GlideModule来实现的：12builder.setMemoryCache(new LruResourceCache(yourSizeInBytes));builder.setBitmapPool(new LruBitmapPool(sizeInBytes)); 一般情况下，开发者是不需要自己去指定它们的大小的，因为Glide已经帮我们做好了。默认的内存缓存和bitmapPool的大小由MemorySizeCalculator根据当前设备的屏幕大小和可用内存计算得到。同时Glide还支持动态的缓存大小调整，在存在大量图片的Activity/Fragment中，开发者可以通过setMemoryCategory方法来提高Glide的内存缓存大小，从而加快图片的加载速度。1Glide.get(context).setMemoryCategory(MemoryCategory.HIGH); MemoryCategory有3个值可供选择： MemoryCategory.HIGH（初始缓存大小的1.5倍） MemoryCategory.NORMAL（初始缓存大小的1倍） MemoryCategory.LOW（初始缓存大小的0.5倍） 在有些情况下我们不希望做内存缓存（比如加载GIF图片），这个时候可以调用skipMemoryCache(true)方法跳过内存缓存。 如何缓存动态Url的图片一般情况下我们从网络上获取到的图片Url都是静态的，即一张图片对应一个Url。那么如果是一张图片对应多个Url呢？缓存不就没有意义了。因为图片加载库都是拿图片的Url来作为缓存的key的，Glide也不例外，只是会更加复杂一些。如果你开启了Glide的log,就会在控制台看到Glide是如何指定缓存key的。关于如何打开log,请参考这篇文章。一般来说，Glide的key由图片的url、view的宽和高、屏幕的尺寸大小和signature组成。 在什么情况下才会出现动态的Url呢？一个很典型的例子就是因为图片的安全问题在原来图片的Url后面加上访问凭证。访问凭证与时间关联，这样一来，在不同时间同一图片的Url就会不同，缓存就会失效。以七牛的私有空间为例，我们来看看如何去缓存这类图片。从七牛关于私有空间的文档中可以得到：最终的Url = 原Url + ?e=过期时间 + token=下载凭证。那么就只需要在Glide缓存时将Url中“?”后面的字符串截去就可以了。 首先新建一个叫做QiNiuImage的类：1234567891011121314151617181920public class QiNiuImage &#123; private final String imageUrl; public QiNiuImage(String imageUrl) &#123; this.imageUrl = imageUrl; &#125; public String getImageUrl() &#123; return imageUrl; &#125; public String getImageId() &#123; if (imageUrl.contains(\"?\")) &#123; return imageUrl.substring(0, imageUrl.lastIndexOf(\"?\")); &#125; else &#123; return imageUrl; &#125; &#125;&#125; 其中getImageUrl方法返回真实的Url，getImageId方法返回未添加下载凭证前的Url。然后再自定义一个实现ModelLoader接口的QiNiuImageLoader:1234567891011121314151617181920212223public class QiNiuImageLoader implements StreamModelLoader&lt;QiNiuImage&gt; &#123; @Override public DataFetcher&lt;InputStream&gt; getResourceFetcher(final QiNiuImage model, int width, int height) &#123; return new HttpUrlFetcher(new GlideUrl(model.getImageUrl())) &#123; @Override public String getId() &#123; return model.getImageId(); &#125; &#125;; &#125; public static class Factory implements ModelLoaderFactory&lt;QiNiuImage, InputStream&gt; &#123; @Override public ModelLoader&lt;QiNiuImage, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123; return new QiNiuImageLoader(); &#125; @Override public void teardown() &#123; /* no op */ &#125; &#125;&#125; 其中HttpUrlFetcher的getId方法就是组成缓存的key的重要部分。这也是我们的核心原理。将这个ModelLoader注册到GlideModule中，并在AndroidManifest.xml中注册:1234567891011public class QiNiuModule implements GlideModule &#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; &#125; @Override public void registerComponents(Context context, Glide glide) &#123; glide.register(QiNiuImage.class, InputStream.class, new QiNiuImageLoader.Factory()); &#125;&#125; 123&lt;meta-data android:name=\"com.yourpackagename.QiNiuModule\" android:value=\"GlideModule\"/&gt; 最后只需要在加载此类图片时，使用下面这段代码就可以了。即使图片的token更换了也不会重新从网络上下载而是直接读取本地缓存。123Glide.with(context) .load(new QiNiuImage(imageUrl) .into(imageView); 参考资料： https://github.com/bumptech/glide/issues/607 https://github.com/bumptech/glide/issues/501","tags":[{"name":"Glide","slug":"Glide","permalink":"http://www.imzhiqiang.com/tags/Glide/"},{"name":"Cache","slug":"Cache","permalink":"http://www.imzhiqiang.com/tags/Cache/"}]},{"title":"Android多媒体框架中几个重要的类","date":"2016-09-24T02:10:09.000Z","path":"2016/09/24/Several-important-classes-in-Android-media-framework/","text":"与iOS中强大的AVFoundation框架相比，Android framework中提供的有关多媒体处理的类可谓屈指可数，但总比没有好吧。今天我们就来谈谈这几个类。 这里提到的多媒体处理主要是指音视频处理。包括音视频的裁剪、合并；视频画面的各种变换，旋转、缩放、翻转；视频滤镜；音视频的播放，快速、慢速、倒序播放等等。 主要涉及到的类有： MediaExtractor：媒体提取器 MediaCodec：编解码器 MediaMuxer：媒体混合器 MediaMetadataRetriever： 获取音视频信息的类 MediaFormat: 包含音视频帧信息的类 GLSurfaceView: 展示openGL渲染的View OpenGL相关的类 MediaExtractor 在Android4.1（API16）加入。可以从一段音视频中提取出一帧一帧的数据，与MediaMuxer配合使用可以完成视频的裁剪和合并，与MediaCodec、GLSurfaceView配合使用可以完成视频的播放。 MediaCodec 在Android4.1（API16）加入。在Android4.3(API18)提供输入可以为Surface。在Android5.0（API21）又增加了异步处理模式。它是一个低等级的媒体编解码器，可以作为编码器，也可以作为解码器。\b可攻可受，嘿嘿嘿。是音视频处理中最为核心的类。 由于相关文档在以前不是很完善，来自Android媒体团队的fadden(现已不在)维护了一个网站 http://bigflake.com/mediacodec/ 。上面有大量的相关资源。此外在stackoverflow上面只要是MeidaCodec相关的问题随处可见fadden的身影。感谢fadden。现在官方文档已经相当详细了，不过都是英文的，对于阅读困难的人，国内也有人进行了翻译。地址在[这里]（http://www.cnblogs.com/xiaoshubao/archive/2016/04/11/5368183.html） 。 MediaMuxer 在Android4.3(API18)。可以合成MP4格式的视频，输入源通常为从MediaExtractor或者MediaCodec提供的已编码的数据。 MediaMetadataRetriever 主要用来获取视频的方向信息。在合成视频时，可纠正视频方向。此外还可以获取视频某一帧画面的bitmap,前提必须是android支持的视频格式。 MediaFormat 内部持有一个包含音视频帧信息的map。 GLSurfaceView 可与MediaPlayer配合，完成视频变换的各种效果实时预览。 OpenGL是一门单独的技术，然而关于其在Android中使用的文档和列子实在太少。唯一的一本书《OpenGL ES应用开发实践指南 Android卷》在网上也买不到，只能去淘宝买复印版。。。","tags":[{"name":"多媒体","slug":"多媒体","permalink":"http://www.imzhiqiang.com/tags/多媒体/"},{"name":"MediaCodec","slug":"MediaCodec","permalink":"http://www.imzhiqiang.com/tags/MediaCodec/"}]},{"title":"如何调试Glide加载图片","date":"2015-12-01T07:23:23.000Z","path":"2015/12/01/2016-01-13-How-to-debug-glide/","text":"前言与其他图片加载库不同，在Glide加载图片的过程中默认是没有任何log输出的。这样使得加载失败的原因难以调试。到底是网络错误还是图片根本就不存在亦或者解码出错，我们不得而知。当然官方也给出了调试的方法，这篇文章就来介绍下如何调试Glide加载图片，内容主要是对官方wiki的翻译。 正文在Glide加载图片过程中出现异常时，默认是没有log输出的。但是Glide给开发者提供了两种方法来查看或者响应这些异常。 调试为了在异常发生时可以看到它们，你可以打开Glide中处理所有媒体加载响应的类GenericRequest的log开关。很简单，在命令行运行下面的指令即可：1adb shell setprop log.tag.GenericRequest DEBUG 如果你将DEBUG替换为VERBOSE，还可以看到详细的请求时间日志。 如果你想禁用log输出，执行：1adb shell setprop log.tag.GenericRequest ERROR 调试工作流 为了查看Glide内部引擎是何时、如何加载图片的，你可以启用这些log:123adb shell setprop log.tag.Engine VERBOSEadb shell setprop log.tag.EngineJob VERBOSEadb shell setprop log.tag.DecodeJob VERBOSE 启用这些log可以帮助你了解到为什么某些资源没有从内存中加载？为什么从外部url加载要重新下载数据？同时这也有助于了解在磁盘缓存时哪些参数需要配置。启用DecodeJob log还可以帮助你了解自定义变换/解码器/编码器等相关问题。 请求监听器虽然启动调试日志很简单，但前提是你可以访问到设备。为了完善Glide已存在或更复杂的错误日志系统，你可以使用RequestListener类。当加载请求失败时onException()方法就会被调用，并给出造成失败的异常或者null(在解码器无法从它获取到的数据中解码出任何有用的东西时)。你可以通过listener() API为每一个请求添加一个监听器。 确保onException()方法的返回值为false，避免覆盖Glide默认的错误处理（比如加载失败的错误图片占位）。 这里有一个实现快速调试的列子:12345678910111213// 示例: .listener(new LoggingListener&lt;String, GlideDrawable&gt;())public class LoggingListener&lt;T, R&gt; implements RequestListener&lt;T, R&gt; &#123; @Override public boolean onException(Exception e, Object model, Target target, boolean isFirstResource) &#123; android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT, \"onException(%s, %s, %s, %s)\", e, model, target, isFirstResource), e); return false; &#125; @Override public boolean onResourceReady(Object resource, Object model, Target target, boolean isFromMemoryCache, boolean isFirstResource) &#123; android.util.Log.d(\"GLIDE\", String.format(Locale.ROOT, \"onResourceReady(%s, %s, %s, %s, %s)\", resource, model, target, isFromMemoryCache, isFirstResource)); return false; &#125;&#125; 确保在发布应用时移除掉所有的调试log! 更多的log指令这个列表是基于Glide 3.6.0版本的，并不完整。 12345678910111213141516171819202122232425262728293031cd .../android-sdk/platform-toolsadb shell setprop log.tag.AnimatedGifEncoder VERBOSEadb shell setprop log.tag.AssetUriFetcher VERBOSEadb shell setprop log.tag.BitmapEncoder VERBOSEadb shell setprop log.tag.BufferedIs VERBOSEadb shell setprop log.tag.ByteArrayPool VERBOSEadb shell setprop log.tag.CacheLoader VERBOSEadb shell setprop log.tag.ContentLengthStream VERBOSEadb shell setprop log.tag.DecodeJob VERBOSEadb shell setprop log.tag.DiskLruCacheWrapper VERBOSEadb shell setprop log.tag.Downsampler VERBOSEadb shell setprop log.tag.Engine VERBOSEadb shell setprop log.tag.EngineRunnable VERBOSEadb shell setprop log.tag.GenericRequest VERBOSEadb shell setprop log.tag.GifDecoder VERBOSEadb shell setprop log.tag.GifEncoder VERBOSEadb shell setprop log.tag.GifHeaderParser VERBOSEadb shell setprop log.tag.GifResourceDecoder VERBOSEadb shell setprop log.tag.Glide VERBOSEadb shell setprop log.tag.ImageHeaderParser VERBOSEadb shell setprop log.tag.ImageVideoDecoder VERBOSEadb shell setprop log.tag.IVML VERBOSEadb shell setprop log.tag.LocalUriFetcher VERBOSEadb shell setprop log.tag.LruBitmapPool VERBOSEadb shell setprop log.tag.MediaStoreThumbFetcher VERBOSEadb shell setprop log.tag.MemorySizeCalculator VERBOSEadb shell setprop log.tag.PreFillRunner VERBOSEadb shell setprop log.tag.ResourceLoader VERBOSEadb shell setprop log.tag.RMRetriever VERBOSEadb shell setprop log.tag.StreamEncoder VERBOSEadb shell setprop log.tag.TransformationUtils VERBOSE","tags":[{"name":"调试","slug":"调试","permalink":"http://www.imzhiqiang.com/tags/调试/"},{"name":"Glide","slug":"Glide","permalink":"http://www.imzhiqiang.com/tags/Glide/"}]},{"title":"记录一次v4包中SwipeRefreshLayout的“坑爹”事件","date":"2015-11-19T05:29:16.000Z","path":"2015/11/19/2016-01-13-An-accident-about-SwipeRefreshLayout-in-support-v4-package/","text":"当android support v4包和v7包版本不一样时，v4包中的SwipeRefreshLayout和v7包中的RecyclerView不能很好地一起工作，会导致SwipeRefreshLayout下拉刷新时动画卡住的情况，类似下面的情况： 详情请参考: http://stackoverflow.com/questions/33032036/swiperefreshlayout-freezes-on-api-4-2-2。 如果你的项目中用到了photoview，并且targetSdk还是22的话，请不要使用默认的Gradle引用：1compile &apos;com.commit451:PhotoView:1.2.4&apos; 因为这个版本的photoview默认依赖了support v4 23.0.1版本，使得23.0.1版本中的SwipeRefreshLayout和22版本中的RecyclerView不能很好地协调工作。 可以使用下面的引用来引入photoview:1compile &apos;com.github.chrisbanes.photoview:library:1.2.4&apos; 如果不是特意去查看，你还很难发现这个细节，因为targetSdk为22的情况下是不会引用23.0.1版本的v4包的，除非你项目中有其他的library引用了。 小结在引入官方support库时，务必保证版本一致；在引入第三方库时，务必查看第三方库的依赖库，免坑。","tags":[{"name":"坑","slug":"坑","permalink":"http://www.imzhiqiang.com/tags/坑/"},{"name":"SwipeRefreshLayout","slug":"SwipeRefreshLayout","permalink":"http://www.imzhiqiang.com/tags/SwipeRefreshLayout/"}]},{"title":"使用Glide加载图片系列之一从不同的数据源加载图片","date":"2015-10-27T14:12:47.000Z","path":"2015/10/27/2015-10-27-Load-images-from-difference-data-sources/","text":"与其他图片加载库相同，Glide除了可以加载网络图片之外，也可以加载本地图片。甚至还可以从各种各样奇葩的数据源中加载图片。 加载网络图片很多情况下，我们使用图片加载库就是为了加载网络图片。网络操作是一个很复杂的东西。试想一下，如果没有图片加载库，我们就要手动去下载图片,缓存图片，最后再从文件里面读取bitmap并设置到Imageview里面。这还算好的，要是在Listview里面你会更头疼的。原因我就不说了，你懂的~~再加上各种各样的Bitmap操作，保准你再也不想撸代码了。而且Bitmap这东西还很占内存，伺候不好，很容易就会引发OOM，app吧唧就闪退了！！ 图片加载库的优势就在于此。简简单单一句话，下载，缓存，加载统统搞定。简直就是美好一生的东西。而Glide就是这样使人美好一生的东西之一。 说了这么多，Glide如何加载网络图片？很简单，就上次的三句话:123456ImageView targetImageView = (ImageView) findViewById(R.id.imageView);String internetUrl = \"http://i.imgur.com/idojSYm.png\";Glide .with(context) .load(internetUrl) .into(targetImageView); 木有什么乱七八糟的东西，直接传入要加载图片的url就可以了。那么图片加载库有很多，为什么选择Glide呢？很简单，因为它流畅，不卡，尤其是在Listview中。嗯，就是酱~ 加载本地图片下表是.load()可以传入的参数及说明 参数 说明 .load(String string) string可以为一个文件路径、uri或者url .load(Uri uri) uri类型 .load(File file) 文件 .load(Integer resourceId) 资源Id,R.drawable.xxx或者R.mipmap.xxx .load(byte[] model) byte[]类型 .load(T model) 自定义类型 从上面可以看到Glide不仅可以加载网络图片，还可以加载本地图片。可接受的参数有文件路径，uri，文件，资源id等。基本上满足了大部分的需求。虽然加载本地图片不像网络图片那样复杂，但我还是建议使用Glide来加载本地图片。因为它是内存友好的，而且还会“偷偷地”帮我们做很多事情。比如内存缓存，Bitmap复用，修正照片方向等。当然为了满足各种各样的需求，仅仅加载图片是不够的，你还需要对图片进行各种各样的变换，也就是Transformation。后面我们会详细了解的。 加载自定义数据源前面的表格中有一个是我们不熟悉的，就是.load(T model)，即自定义的数据源类型。那么如何去实现呢？ 实际上，加载自定义数据源主要是通过ModelLoader接口来实现的。由于没有在实际项目中用到过，这方面的经验比较少。想深入了解的，可以参考这篇文章。 不过从官方Wiki上来看，设计ModelLoader接口的初衷用来加载不同尺寸的图片的。众所周知，Android设备屏幕分辨率千奇百怪，大到2K，小到320p。如果在低分辨率的手机上加载大图，不仅损耗用户流量，而且很容易造成OOM；在高分辨的手机上，加载小图又会出现模糊的情况，用户体验极差。很多时候，为了省事，很多app都会选择一个中间分辨率，然后自适应大小。当然这样做无可厚非，但是有更好的办法，我们为什么不去尝试呢？ 那么如何使用Glide来实现这一具体需求呢？首先你要实现自己的ModelLoader，比较简单的方法是继承BaseGlideUrlLoader。12345678910public interface MyDataModel &#123; public String buildUrl(int width, int height);&#125;public class MyUrlLoader extends BaseGlideUrlLoader&lt;MyDataModel&gt; &#123; @Override protected String getUrl(MyDataModel model, int width, int height) &#123; // Construct the url for the correct size here. return model.buildUrl(width, height); &#125;&#125; 接下来我们可以这样来加载图片：12345678910111213Glide.with(this) .using(new MyUrlLoader(this)) .load(new MyDataModel() &#123; @Override public String buidUrl(int width, int height) &#123; if (width &gt;= 600) &#123; return url1; &#125; else &#123; return url2; &#125; &#125; &#125;) .into(imageView); .using(new MyUrlLoader(this))：使用我们自己的ModeLoader;.load(new MyDataModel()):加载我们自定义的数据源 这里需要解释下getUrl的三个参数：model：你加载的数据源width：你加载的图片的宽度(px)height：你加载的图片的高度(px) 这样，我们在高分率的设备上加载大图的url1，在低分辨率的设备上加载小图url2。从而实现了根据不同手机上的像素值大小加载不同尺寸的图片的需求。 当然如果你不想每次都是用.using(new MyUrlLoader())，就需要实现一个自定义的ModelLoaderFactory并在GlideModule中注册。12345678public class MyGlideModule implements GlideModule &#123; ... @Override public void registerComponents(Context context, Glide glide) &#123; glide.register(MyDataModel.class, InputStream.class, new MyUrlLoader.Factory()); &#125;&#125; 同时也要在AndroidManifest.xml声明123&lt;meta-data android:name=\"com.mypackage.MyGlideModule\" android:value=\"GlideModule\" /&gt; 如果你有多个自定义的GlideModule类，那么也要在AndroidManifest.xml中声明多个GlideModule。 对于上面的加载不同尺寸的图片，Google的2014年I/O大会App中有一篇文章专门用来介绍这个的，地址在这里。大概原理是这样子的： 在服务端有下面的几个可以加载的url： URL 图片大小 myserver.com/images/__w-200-400-600-800-1000__/session1.jpg 原始尺寸 myserver.com/images/w200/session1.jpg 200px myserver.com/images/w400/session1.jpg 400px myserver.com/images/w600/session1.jpg 600px myserver.com/images/w800/session1.jpg 800px myserver.com/images/w1000/session1.jpg 1000px 那么客户端如何根据不同的手机分辨率去加载不同的url呢？ Google是这样做的，下面是核心代码： 123456789101112131415161718192021222324//定义正则表达式private static final Pattern PATTERN = Pattern.compile(\"__w-((?:-?\\\\d+)+)__\");@Overrideprotected String getUrl(String model, int width, int height) &#123; Matcher m = PATTERN.matcher(model); int bestBucket = 0; if (m.find()) &#123; String[] found = m.group(1).split(\"-\");//拿到可以加载的尺寸数组 for (String bucketStr : found) &#123; bestBucket = Integer.parseInt(bucketStr); if (bestBucket &gt;= width) &#123;//刚好大于要加载的尺寸，直接跳出循环 // the best bucket is the first immediately // bigger than the requested width break; &#125; &#125; if (bestBucket &gt; 0) &#123;//返回合适尺寸的url model = m.replaceFirst(\"w\"+bestBucket); &#125; &#125; return model;&#125; 大概的步骤如下：1.根据服务端可加载的图片url定义正则表达式2.根据正则匹配，获取到可以加载的图片尺寸数组3.根据要加载的Imageview的大小，选择合适的尺寸的url4.拼接url并返回 上面的例子中有200,400,600,800,1000是可以加载的，如果你要加载的Imageview的大小为600px,当遍历数组到600时，就会直接跳出循环，返回600px大小图片的url，Glide就会加载600px的图片。 最后送上一个小demo:https://github.com/Alluretears/GldieDemo","tags":[{"name":"Glide","slug":"Glide","permalink":"http://www.imzhiqiang.com/tags/Glide/"},{"name":"数据源","slug":"数据源","permalink":"http://www.imzhiqiang.com/tags/数据源/"}]},{"title":"使用Glide加载图片系列之零初识Glide","date":"2015-10-27T14:04:06.000Z","path":"2015/10/27/2015-10-27-Hello-Glide/","text":"废话不多说，开撸（Junk Words No More Say,Let’s LOL） 咋添加Glide依赖呀？一句话（One Word）：1compile &apos;com.github.bumptech.glide:glide:3.6.1&apos; 不多说(No More Say)。 PhotoShop:如果你还在用一颗利普斯(eclipse)，请前往Glide在github上的发布页，下载最新的jar包吧，地址是sha？自己找→_→ 最简单的加载方式123456ImageView targetImageView = (ImageView) findViewById(R.id.imageView);String internetUrl = \"http://i.imgur.com/idojSYm.png\";Glide .with(context) .load(internetUrl) .into(targetImageView); 这都嘛意思啊？莫慌，我来装下B: .with(Context context),此处的context就是你熟悉的context，没啥不一样的。就是有一点，里面可以是fragment。 .load(String imageUrl),你要加载的图片地址，当然也可以是uri或者file,亦或是R.drawable.xxxx。 .into(ImageView targetImageView)，你要加载的Imageview控件，当然也可以一个view,不过那都是后话。","tags":[{"name":"Glide","slug":"Glide","permalink":"http://www.imzhiqiang.com/tags/Glide/"},{"name":"图片加载库","slug":"图片加载库","permalink":"http://www.imzhiqiang.com/tags/图片加载库/"}]},{"title":"Glide ：一个专注于平滑滚动的图片加载和缓存库","date":"2015-08-23T08:19:12.000Z","path":"2015/08/23/2015-08-23-Some-tips-with-Glide/","text":"在图片加载库烂大街的今天，选择一个适合自己使用的图片加载库已经成为了每一个Android开发者的必经之路。现在市面上知名的图片加载库有UIL,Picasso,Volley ImageLoader,Fresco以及我们今天的主角Glide。它们各有千秋，不能评定谁一定比谁好，只能说哪一个更适合你。 我的理解下面我来谈一下个人对这些图片加载库的理解，如有错误，还望指教。 Universal Image Loader：一个强大的图片加载库，包含各种各样的配置，最老牌，使用也最广泛。 Picasso: Square出品，必属精品。和OkHttp搭配起来更配呦！ Volley ImageLoader：Google官方出品，可惜不能加载本地图片~ Fresco：Facebook出的，天生骄傲！不是一般的强大。 Glide：Google推荐的图片加载库，专注于流畅的滚动。 更多详情请看stackoverflow上这个问题。 初试Glide下面进入今天的主题，相信之前很多同学都看到过这篇介绍Glide的文章,中文版在这里。文中从各个方面介绍和比较了Glide与Picasso，总体来说二者极为相似，有着近乎相同的API的使用风格。但Glide在缓存策略和加载GIF方面略胜一筹。最后作者也极力推荐了这个库。 而且据说在Google新出的Photos应用中，到处可见Glide的踪迹。看到这里，你是不是已经迫不及待的想试一试这个库呢？就在你下定决心尝试一记的时候，你又听说Yelp app(据说是美国的大众点评)也在使用这个吊炸天的库。你的心中激动万分，发四一定要使用这个库。说干就干，打开Android Studio，在builde.gradle里面添加上1compile 'com.github.bumptech.glide:glide:3.6.1' 然后全局搜索图片加载的地方，全部换成了下面的代码：12345Glide.with(mContext) .load(url) .placeholder(R.drawable.loading_spinner) .crossFade() .into(myImageView); 在经过漫长的编译过程之后，再次打开APP，看到有着渐现效果的图片呈现在你的面前，你不禁叫道：“wocao,真TM帅！为什么我以前没有发现呢？”。 不过在你使用了几天之后你会发现一些问题： 为什么 有的图片第一次加载的时候只显示占位图，第二次才显示正常的图片呢？ 为什么 我总会得到类似You cannot start a load for a destroyed activity这样的异常呢？ 为什么 我不能给加载的图片setTag()呢？ 为什么？为什么？这么NB的库竟然会有这么多的问题。没错，这就是我今天要讲的重点。怎么避免上面的问题发生。 一些解决方案1.如果你刚好使用了这个圆形Imageview库或者其他的一些自定义的圆形Imageview，而你又刚好设置了占位的话，那么，你就会遇到第一个问题。如何解决呢？方案一: 不设置占位；方案二：使用Glide的Transformation API自定义圆形Bitmap的转换。这里是一个已有的例子；方案三：使用下面的代码加载图片：123456789Glide.with(mContext) .load(url) .placeholder(R.drawable.loading_spinner) .into(new SimpleTarget&lt;Bitmap&gt;(width, height) &#123; @Override public void onResourceReady(Bitmap bitmap, GlideAnimation anim) &#123; // setImageBitmap(bitmap) on CircleImageView &#125; &#125;; 2.至于第二个问题，请记住一句话：不要再非主线程里面使用Glide加载图片，如果真的使用了，请把context参数换成getApplicationContext。更多的细节请参考这个issue。 3.为什么不能设置Tag，是因为你使用的姿势不对哦。如何为ImageView设置Tag呢？且听我细细道来。方案一：使用setTag(int,object)方法设置tag,具体用法如下：Java代码是酱紫的：12345678Glide.with(context).load(urls.get(i).getUrl()).fitCenter().into(imageViewHolder.image); imageViewHolder.image.setTag(R.id.image_tag, i); imageViewHolder.image.setOnClickListener(new View.OnClickListener() &#123; @Override int position = (int) v.getTag(R.id.image_tag); Toast.makeText(context, urls.get(position).getWho(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 同时在values文件夹下新建ids.xml，添加1&lt;item name=\"image_tag\" type=\"id\"/&gt; 大功告成! 方案二：从Glide的3.6.0之后，新添加了全局设置的方法。具体方法如下：先实现GlideMoudle接口，全局设置ViewTaget的tagId:1234567891011public class MyGlideMoudle implements GlideModule&#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; ViewTarget.setTagId(R.id.glide_tag_id); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; &#125;&#125; 同样，也需要在ids.xml下添加id1&lt;item name=\"glide_tag_id\" type=\"id\"/&gt; 最后在AndroidManifest.xml文件里面添加123&lt;meta-data android:name=\"com.yourpackagename.MyGlideMoudle\" android:value=\"GlideModule\" /&gt; 又可以愉快的玩耍了，嘻嘻`(∩_∩)′。 方案三：写一个继承自ImageViewTaget的类，复写它的get/setRequest方法。12345678910111213141516171819202122232425Glide.with(context).load(urls.get(i).getUrl()).fitCenter().into(new ImageViewTarget&lt;GlideDrawable&gt;(imageViewHolder.image) &#123; @Override protected void setResource(GlideDrawable resource) &#123; imageViewHolder.image.setImageDrawable(resource); &#125; @Override public void setRequest(Request request) &#123; imageViewHolder.image.setTag(i); imageViewHolder.image.setTag(R.id.glide_tag_id,request); &#125; @Override public Request getRequest() &#123; return (Request) imageViewHolder.image.getTag(R.id.glide_tag_id); &#125; &#125;); imageViewHolder.image.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; int position = (int) v.getTag(); Toast.makeText(context, urls.get(position).getWho(), Toast.LENGTH_SHORT).show(); &#125; &#125;); 一些使用技巧1.Glide.with(context).resumeRequests()和 Glide.with(context).pauseRequests() 当列表在滑动的时候，调用pauseRequests()取消请求，滑动停止时，调用resumeRequests()恢复请求。这样是不是会好些呢？ 2.Glide.clear() 当你想清除掉所有的图片加载请求时，这个方法可以帮助到你。 3.ListPreloader 如果你想让列表预加载的话，不妨试一下ListPreloader这个类。 一些基于Glide的优秀库1.glide-transformations 一个基于Glide的transformation库，拥有裁剪，着色，模糊，滤镜等多种转换效果，赞的不行不行的~~ 2.GlidePalette 一个可以在Glide加载时很方便使用Palette的库。","tags":[{"name":"Glide","slug":"Glide","permalink":"http://www.imzhiqiang.com/tags/Glide/"},{"name":"图片加载库","slug":"图片加载库","permalink":"http://www.imzhiqiang.com/tags/图片加载库/"}]},{"title":"HelloWorld","date":"2015-07-26T10:52:50.000Z","path":"2015/07/26/2015-06-20-HelloWorld/","text":"端午节突然想用Github Pages搭一个自己的博客。折腾了一天，终于搞定了。感谢Github，提供了一个免费的空间；感谢hexo的创造者，帮我解决了很多头疼的事情；感谢网上的各路大神，让我一路披荆斩棘，最后成功搭建博客。 以后这就是额的小天地了，先来篇HelloWorld，然后安安静静地做自己的码农吧！ 最后感谢黎小腾同学的Yilia主题，我很喜欢！","tags":[{"name":"博客","slug":"博客","permalink":"http://www.imzhiqiang.com/tags/博客/"},{"name":"hexo","slug":"hexo","permalink":"http://www.imzhiqiang.com/tags/hexo/"},{"name":"处女篇","slug":"处女篇","permalink":"http://www.imzhiqiang.com/tags/处女篇/"},{"name":"随笔","slug":"随笔","permalink":"http://www.imzhiqiang.com/tags/随笔/"}]},{"title":"Retrofit系列之二：Retrofit的基本身份验证（译）","date":"2015-07-16T11:44:11.000Z","path":"2015/07/16/2015-07-16-Retrofit-Basic-Authentication-on-Android/","text":"这是Retrofit系列文章的第二篇。将介绍了如何使用Retrofit完成用户名/邮箱和密码的身份验证。 在前面的章节里，我们已经创建了一个初始版本的API/HTTP请求客户端。我们会在此基础上增加基本的身份验证功能。 集成基本的身份验证让我们更新下ServiceGenerator类，创建一个添加验证的方法。下面的代码片段是基于上面的类的。同时也为下面1.9版本的代码添加了2.0的示例。如果你依赖于Retrofit 2.0版本，可以直接跳过1.9的例子，直接看第二个代码块:) Retrofit 1.9123456789101112131415161718192021222324252627282930313233public class ServiceGenerator &#123; public static final String API_BASE_URL = \"http://your.api-base.url\"; private static RestAdapter.Builder builder = new RestAdapter.Builder() .setEndpoint(API_BASE_URL) .setClient(new OkClient(new OkHttpClient())); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) &#123; return createService(serviceClass, null, null); &#125; public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass, String username, String password) &#123; if (username != null &amp;&amp; password != null) &#123; // concatenate username and password with colon for authentication String credentials = username + \":\" + password; // create Base64 encodet string final String basic = \"Basic \" + Base64.encodeToString(credentials.getBytes(), Base64.NO_WRAP); builder.setRequestInterceptor(new RequestInterceptor() &#123; @Override public void intercept(RequestFacade request) &#123; request.addHeader(\"Authorization\", basic); request.addHeader(\"Acceppt\", \"application/json\"); &#125; &#125;); &#125; RestAdapter adapter = builder.build(); return adapter.create(serviceClass); &#125;&#125; Retrofit 212345678910111213141516171819202122232425262728293031323334353637383940public class ServiceGenerator &#123; public static final String API_BASE_URL = \"http://your.api-base.url\"; private static OkHttpClient httpClient = new OkHttpClient(); private static Retrofit.Builder builder = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) &#123; return createService(serviceClass, null, null); &#125; public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass, String username, String password) &#123; if (username != null &amp;&amp; password != null) &#123; String credentials = username + \":\" + password; final String basic = \"Basic \" + Base64.encodeToString(credentials.getBytes(), Base64.NO_WRAP); httpClient.interceptors().add(new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request original = chain.request(); Request.Builder requestBuilder = original.newBuilder() .header(\"Authorization\", basic); .header(\"Accept\", \"applicaton/json\"); .method(original.method(), original.body()); Request request = requestBuilder.build(); return chain.proceed(request); &#125; &#125;); &#125; Retrofit retrofit = builder.client(httpClient).build(); return retrofit.create(serviceClass); &#125;&#125; 新的方法有两个参数：用户名 和 密码。当然你也可以用邮箱来代替用户名。与在第一个方法中创建客户端的方法是一样的：使用 RestAdapter (Retrofit 2中为Retrofit)类设置基本的url和OkHttpClient。 不同的是：我们使用一个请求拦截器 RequestInterceptor (Retrofit 2中为Interceptor )来设置基础url Http请求的头信息。如果提供了用户名和密码，会执行新的方法。如果用户名和密码不正确时，会创建第一个方法中的客户端。这是我们简化第一个方法的原因。 在验证部分我们必须调整用户名/邮箱和密码的格式。基础身份验证需要一个冒号连接两个值的字符串。此外，新创建的字符串必须经过Base64编码。 几乎任何一个webservice和API的验证都是在HTTP的请求头里面的。这是我们在请求头里面设置编码值的原因。 如果你想接收特殊格式的服务器响应时，Accent头是很重要的。例如，我们想接收JSON格式的响应，因为Retrofit和Google的GSON配合会将java对象序列化为JSON,反过来也可以。 用法调用我们之前写的ServiceGenerator类的新方法。例如，下面代码定义的LoginService。 Retrofit 1.91234public interface LoginService &#123; @POST(\"/login\") User basicLogin();&#125; Retrofit 21234public interface LoginService &#123; @POST(\"/login\") Call&lt;User&gt; basicLogin();&#125; 上面的接口只包含一个baseLogin的方法。该方法返回User类型，没有任何的查询参数。 现在你可以通过给定的证书（用户名和密码）创建你的HTTP客户端了。 Retrofit 1.9123LoginService loginService = ServiceGenerator .createService(LoginService.class, \"user\", \"secretpassword\");User user = loginService.login(); Retrofit 21234LoginService loginService = ServiceGenerator .createService(LoginService.class, \"user\", \"secretpassword\");Call&lt;User&gt; call = loginService.login(); User user = call.execute().body(); ServiceGenerator 的方法会创建一个包含验证信息的HTTP客户端。一旦你调用loginService的basicLogin方法，被提供的证书将会被自动传递到你定义的基础url了。 接下来是什么下篇文章将介绍如何使用Retrofit实现OAuth。 原文地址：https://futurestud.io/blog/android-basic-authentication-with-retrofit/","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.imzhiqiang.com/tags/Retrofit/"},{"name":"身份验证","slug":"身份验证","permalink":"http://www.imzhiqiang.com/tags/身份验证/"},{"name":"Authentication","slug":"Authentication","permalink":"http://www.imzhiqiang.com/tags/Authentication/"}]},{"title":"Retrofit系列之一：开始创建Retrofit客户端（译）","date":"2015-07-09T15:07:16.000Z","path":"2015/07/09/2015-07-09-Retrofit-Getting-Started-and-Create-an-Android-Client/","text":"这是Retrofit系列文章的第一篇。该系列通过通过几个用例来探讨Retrofit的功能和扩展。 这篇博文中，我们将通过Retrofit的基础知识来创建一个API或者Http请求的Android客户端。 然而，这篇文章并不包含太多关于Retrofit和如何开始使用她的信息，如果你想了解更多，请访问该项目的主页。 什么是Retrofit据Retrofit的官方页面描述，她是 一个类型安全的Android或Java的REST客户端 你可以使用注解来描述Http请求，URL参数替换，查询参数支持。这些都是默认集成的。此外，她还提供了多种多样的请求体和文件上传。 如何声明(API)请求请访问Retrofit的主页阅读她的API文档说明，了解如何发起请求。通过清晰的代码示例你会获取到所有的重要信息。 准备你的Android工程现在让我们的手回到键盘开始干活。如果你已经创建好工程，请直接看下一段。不然你就在你喜爱的IDE里面新建一个项目。我们更倾向于Gradle的构建系统，如果你使用Maven也是可以的。 声明依赖：Gradle或者Maven现在让我们为自己的工程添加Retrofit的依赖。选择你的构建系统在pom.xml或者build.gradle里面声明Retrofit的依赖。当构建系统开始编译你的代码时，他会自动下载并为工程添加依赖库。我们也倾向于把Retrofit和OkHTTP结合使用。 Retrofit 1.9pom.xml12345678910&lt;dependency&gt; &lt;groupId&gt;com.squareup.retrofit&lt;/groupId&gt; &lt;artifactId&gt;retrofit&lt;/artifactId&gt; &lt;version&gt;1.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;2.4.0&lt;/version&gt;&lt;/dependency&gt; build.gradle1234dependencies &#123; compile &apos;com.squareup.retrofit:retrofit:1.9.0&apos; compile &apos;com.squareup.okhttp:okhttp:2.4.0&apos;&#125; Retrofit 2如果你正在使用Retrofit 2请使用下面的依赖。 pom.xml12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.retrofit&lt;/groupId&gt; &lt;artifactId&gt;retrofit&lt;/artifactId&gt; &lt;version&gt;2.2.0-beta2&lt;/version&gt;&lt;/dependency&gt; build.gradle1234dependencies &#123; // Retrofit &amp; OkHttp compile &apos;com.squareup.retrofit:retrofit:2.0.0-beta2&apos;&#125; Retrofit 2现在已经默认使用OkHttp作为网络层。你不需要为你的工程添加OkHttp的依赖了，除非你需要一个特定的版本。 现在你的工程已经集成了Retrofit，让我们创造一个持久的Android API/HTTP客户端。 可持续的Android客户端在研究已存在的Retrofit的客户端时，Bart Kiers的仓库出现了。事实上，它是一个使用Retrofit的Oauth验证实例。它为一个可持续的Android客户端提供了必要的基本原理。这是我们为什么使用它作为一个稳定的基础。在未来的博文中，我们会进一步扩展验证功能。 下面的类定义了我们Android客户端的基础：ServiceGenerator Service GeneratorServiceGenerator是我们API/HTTP客户端的核心.现在, 她仅仅定义了一个方法为给定的类或者接口创建一个基本的REST adapter。这里是代码： Retrofit 1.912345678910111213public class ServiceGenerator &#123; public static final String API_BASE_URL = \"http://your.api-base.url\"; private static RestAdapter.Builder builder = new RestAdapter.Builder() .setEndpoint(API_BASE_URL) .setClient(new OkClient(new OkHttpClient())); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) &#123; RestAdapter adapter = builder.build(); return adapter.create(serviceClass); &#125;&#125; Retrofit 2123456789101112131415public class ServiceGenerator &#123; public static final String API_BASE_URL = \"http://your.api-base.url\"; private static OkHttpClient httpClient = new OkHttpClient(); private static Retrofit.Builder builder = new Retrofit.Builder() .baseUrl(API_BASE_URL) .addConverterFactory(GsonConverterFactory.create()); public static &lt;S&gt; S createService(Class&lt;S&gt; serviceClass) &#123; Retrofit retrofit = builder.client(httpClient).build(); return retrofit.create(serviceClass); &#125;&#125; ServiceGenerator 类使用Retrofit的 RestAdapter-Builder 来创建一个新的REST客户端通过一个被给定基础url的API。例如,GitHub的API基础url是 https://developer.github.com/v3/ 。serviceClass 定义了API请求的类或者接口。下面展示了Retrofit的用法和如何定义一个实例客户端。 JSON MappingRetrofit 1.9默认使用Google的Gson。你所要做的就是定义你的响应对象类，响应会自动映射为Java对象。 当使用Retrofit 2时，你需要为Retrofit对象添加一个converter。这就是我们为什么会集成GSON到在Retrofit构建过程中要调用 .addConverterFactory(GsonConverterFactory.create()) 的原因了。 使用Retrofit好, 现在让我们定义一个从github请求数据的客户端实例。首先，我们需要创建一个接口并定义一个所需的方法。 GitHub客户端下面的代码定义了 GitHubClient 和一个请求某仓库贡献者列表的方法。它说明了Retrofit参数替代功能的用法。（当调用方法时，指定路径中的owner和repo将会被替换为给定的变量） Retrofit 1.91234567public interface GitHubClient &#123; @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\") List&lt;Contributor&gt; contributors( @Path(\"owner\") String owner, @Path(\"repo\") String repo );&#125; Retrofit 21234567public interface GitHubClient &#123; @GET(\"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors\") Call&lt;List&lt;Contributor&gt;&gt; contributors( @Path(\"owner\") String owner, @Path(\"repo\") String repo );&#125; 这是Contributor类的定义.该类包含了响应数据映射所需的属性。1234static class Contributor &#123; String login; int contributions; &#125; 关于前面提到的JSON映射：GitHubClient 定义了一个名为 contributors 返回类型为 List 的方法。Retrofit确保服务器响应可以正确的得到映射。（在响应与给定的类匹配时） API实例请求下面的代码片段说明了ServiceGenerator实例化你客户端的用法。Github客户端通过调用方法来获取仓库贡献者的列表。这段代码是一个Retrofit GitHub客户端示例的修改版。 你需要为 ServiceGenerator 手动定义一个基本的url https://developer.github.com/v3/ 。 Retrofit 1.912345678910111213public static void main(String... args) &#123; // Create a very simple REST adapter which points the GitHub API endpoint. GitHubClient client = ServiceGenerator.createService(GitHubClient.class); // Fetch and print a list of the contributors to this library. List&lt;Contributor&gt; contributors = client.contributors(\"fs_opensource\", \"android-boilerplate\"); for (Contributor contributor : contributors) &#123; System.out.println( contributor.login + \" (\" + contributor.contributions + \")\"); &#125;&#125; Retrofit 2123456789101112131415public static void main(String... args) &#123; // Create a very simple REST adapter which points the GitHub API endpoint. GitHubClient client = ServiceGenerator.createService(GitHubClient.class); // Fetch and print a list of the contributors to this library. Call&lt;List&lt;Contributor&gt;&gt; call = client.contributors(\"fs_opensource\", \"android-boilerplate\"); List&lt;Contributor&gt; contributors = call.execute().body(); for (Contributor contributor : contributors) &#123; System.out.println( contributor.login + \" (\" + contributor.contributions + \")\"); &#125;&#125; 接下来是什么下篇文章将阐述如何使用Retrofit实现一个基本验证。 很高兴您可以阅读Retrofit系列的第一篇文章:) 原文地址：https://futurestud.io/blog/retrofit-getting-started-and-android-client/","tags":[{"name":"Retrofit","slug":"Retrofit","permalink":"http://www.imzhiqiang.com/tags/Retrofit/"},{"name":"REST","slug":"REST","permalink":"http://www.imzhiqiang.com/tags/REST/"},{"name":"HTTP请求","slug":"HTTP请求","permalink":"http://www.imzhiqiang.com/tags/HTTP请求/"}]}]